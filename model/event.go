package model

import (
	"slices"
	"strings"
	"time"
)

const (
	Heartbeat     = "heartbeat"
	CoreState     = "core-state"
	DetailState   = "detail-state"
	Error         = "error"
	UserGenerated = "user-generated"
	AutoGenerated = "auto-generated"
	StartUp       = "startup"
	RoomDivide    = "roomdivide"
	Metrics       = "metrics"
	Internal      = "internal"
	RoomSystem    = "room-system"
	Alert         = "alert"
	Computer      = "computer"
	Mstatus       = "mstatus"
	Via           = "via"
	Hardware_Info = "hardware-info"
	ActiveSignal  = "active-signal"
	Support       = "support"

	UICommunication = "ui-communication"
	UIEvent         = "ui-event"
	CherryUI        = "cherry-ui"
	BlueberryUI     = "blueberry-ui"
)

// An Event is generated when something happens on the system.
// It enables other systems to react to changes and collect metrics.
type Event struct {
	GeneratingSystem string          `json:"generating-system"`
	Timestamp        time.Time       `json:"timestamp"`
	EventTags        []string        `json:"event-tags"`
	TargetDevice     BasicDeviceInfo `json:"target-device"`
	AffectedRoom     BasicRoomInfo   `json:"affected-room"`
	Key              string          `json:"key"`            // the key of the event, e.g. "heartbeat", "core-state", etc.
	Value            string          `json:"value"`          // the value of the event, e.g. "online", "offline", etc.
	User             string          `json:"user"`           // the user who generated the event, if applicable
	Data             interface{}     `json:"data,omitempty"` // additional data associated with the event
}

// BasicDeviceInfo contains minimal information about a device.
type BasicDeviceInfo struct {
	BasicRoomInfo
	DeviceID string `json:"deviceID,omitempty"` // the ID of the device
}

// BasicRoomInfo contains minimal information about a room.
type BasicRoomInfo struct {
	BuildingID string `json:"buildingID,omitempty"` // the ID of the building
	RoomID     string `json:"roomID,omitempty"`     // the ID of the room
}

// GenerateBasicDeviceInfo takes a deviceID and generates a BasicDeviceInfo
func GenerateBasicDeviceInfo(deviceID string) BasicDeviceInfo {
	deviceID = strings.ToUpper(deviceID)

	vals := strings.Split(deviceID, "-")
	if len(vals) != 3 {
		return BasicDeviceInfo{DeviceID: deviceID}
	}
	return BasicDeviceInfo{
		BasicRoomInfo: BasicRoomInfo{
			BuildingID: vals[0],
			RoomID:     vals[0] + "-" + vals[1],
		},
		DeviceID: deviceID,
	}
}

// GenerateBasicRoomInfo takes a roomID and generates a BasicRoomInfo
func GenerateBasicRoomInfo(roomID string) BasicRoomInfo {
	roomID = strings.ToUpper(roomID)

	vals := strings.Split(roomID, "-")
	if len(vals) != 2 {
		return BasicRoomInfo{
			RoomID: vals[0],
		}
	}
	return BasicRoomInfo{
		BuildingID: vals[0],
		RoomID:     vals[0] + "-" + vals[1],
	}
}

// AddToTags takes one or more strings and adds them to the list of even tags on the event.
func (e *Event) AddToTags(tags ...string) {
	for _, t := range tags {
		if !ContainsAllTags(*e, t) {
			e.EventTags = append(e.EventTags, t)
		}
	}
}

// ContainsAllTags checks if the event contains all the specified tags.
func ContainsAllTags(e Event, tags ...string) bool {
	for i := range tags {
		hasTag := false
		for j := range e.EventTags {
			if e.EventTags[j] == tags[i] {
				hasTag = true
				continue
			}
		}
		if !hasTag {
			return false
		}
	}
	return true
}

// ContainsAnyTag returns true if the event has at least one of the specified tags.
func ContainsAnyTags(e Event, tags ...string) bool {
	for i := range tags {
		if slices.Contains(e.EventTags, tags[i]) {
			return true
		}
	}
	return false
}
